"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const date_fns_1 = require("date-fns");
const __1 = require("..");
const automateBrowser_1 = __importDefault(require("../functions/automateBrowser"));
const failure_1 = __importDefault(require("../functions/failure"));
const readHtml_1 = __importDefault(require("../functions/readHtml"));
const success_1 = __importDefault(require("../functions/success"));
const cheerio_1 = __importDefault(require("cheerio"));
class MangaBox {
    constructor(options = {}) {
        this.BLOCKED_DOMAINS = [
            'https://jsc.adskeeper.co.uk/',
            'https://pagead2.googlesyndication.com/',
            'https://mc.yandex.ru/metrika/tag.js',
            'https://mangabox.org/wp-includes/js/wp-emoji-release.min.js?ver=5.8',
            'https://mangabox.org/wp-content/themes/madara/js/core.js',
            'https://mangabox.org/wp-includes/js/jquery/jquery-migrate.min.js?ver=3.3.2',
            'https://mangabox.org/wp-includes/js/wp-embed.min.js',
            'https://mangabox.org/wp-content/plugins/madara-core/assets/js/manga-single.js',
            'https://mangabox.org/wp-includes/js/comment-reply.min.js',
            'https://mangabox.org/wp-content/themes/madara/js/smoothscroll.js',
            'https://mangabox.org/wp-includes/js/imagesloaded.min.js',
            'https://mangabox.org/wp-content/themes/madara/js/bootstrap.min.js',
            'https://mangabox.org/wp-content/themes/madara/js/lazysizes/lazysizes.min.js',
            'https://mangabox.org/wp-content/themes/madara/js/aos.js',
            'https://mangabox.org/wp-content/themes/madara/js/shuffle.min.js?ver=5.3.0',
            'https://mangabox.org/wp-content/plugins/madara-shortcodes/shortcodes/js/ct-shortcodes.js',
            'https://mangabox.org/wp-includes/js/jquery/ui/core.min.js',
            'https://mangabox.org/wp-content/themes/madara/js/slick/slick.min.js',
            'https://mangabox.org/wp-includes/js/jquery/ui/autocomplete.min.js',
            'https://mangabox.org/wp-includes/js/dist/a11y.min.js',
            'https://mangabox.org/wp-includes/js/dist/i18n.min.js',
            'https://mangabox.org/wp-includes/js/dist/hooks.min.js',
            'https://mangabox.org/wp-includes/js/dist/dom-ready.min.js',
            'https://mangabox.org/wp-includes/js/dist/vendor/wp-polyfill.min.js',
            'https://mangabox.org/wp-includes/js/dist/vendor/regenerator-runtime.min.js',
            'https://mangabox.org/wp-includes/js/jquery/ui/menu.min.js',
            'https://mangabox.org/wp-content/plugins/madara-core/assets/slick/slick.min.js',
            'https://mangabox.org/wp-content/plugins/madara-core/assets/js/login.js',
            'https://mangabox.org/wp-content/themes/madara/js/template.js',
            'https://mangabox.org/wp-content/themes/madara/js/ajax.js',
        ];
        this.options = options;
    }
    /**
     * Search up a manga from MangaBox
     *
     * @param query - Query to provide to MangaBox's search
     * @param filters - Filters to apply in MangaBox's search
     * @param callback - Callback function
     * @returns Returns an array of mangas from MangaBox's search results
     * @example
     *
     * ```js
     * await mangabox.search(null, {
     *    genres: {
     *        include: ['Detective', 'Martial Arts'],
     *        condition: 'or'
     *    },
     *    status: ['completed', 'ongoing'],
     *    orderBy: 'trending'
     * })
     * ```
     */
    search(query, filters, callback = () => void 0) {
        if (query == null)
            query = '';
        if (filters == null)
            filters = {};
        const { genres = { include: [], condition: 'and' }, yearReleased, includeNSFW = false, status = 'any', orderBy = 'relevance', } = filters;
        const searchURL = (() => {
            const searchQueryParam = (() => {
                switch (typeof query) {
                    case 'string':
                        return `s=${query.replace(/ /g, '+')}`;
                    case 'object': {
                        const authorParam = query.author ? `author=${query.author}` : '';
                        const artistParam = query.artist ? `artist=${query.artist}` : '';
                        const titleParam = query.title ? `s=${query.title.replace(/ /g, '+')}` : '';
                        return [titleParam, artistParam, authorParam].filter((string) => string.length !== 0).join('&');
                    }
                }
            })();
            const genreParam = (genres === null || genres === void 0 ? void 0 : genres.include)
                ? [
                    ...genres.include.map((genre) => `genre[]=${__1.MangaBoxGenres[genre]}`),
                    `op=${genres.condition === 'and' || genres.condition == null ? '1' : ''}`,
                ].join('&')
                : '';
            const yearReleasedParam = yearReleased ? `release=${yearReleased}` : '';
            const adultContentParam = includeNSFW ? 'adult=' : 'adult=0';
            const statusParam = status === 'any' || status == null
                ? ''
                : Array.isArray(status)
                    ? status.map((statusInput) => `status[]=${__1.MangaBoxStatus[statusInput]}`).join('&')
                    : `status[]=${__1.MangaBoxStatus[status]}`;
            const orderParam = `m_orderby=${__1.MangaBoxOrderBy[orderBy]}`;
            return `https://mangabox.org/?${[
                searchQueryParam,
                'post_type=wp-manga',
                genreParam,
                yearReleasedParam,
                adultContentParam,
                statusParam,
                orderParam,
            ]
                .filter((param) => param.length !== 0)
                .join('&')}`;
        })();
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            try {
                const $ = yield readHtml_1.default(searchURL, this.options);
                const mangaList = $('div.row.c-tabs-item__content');
                const mangaListLength = mangaList.length;
                const mangas = [];
                for (let i = 0; i < mangaListLength; i++) {
                    const divContainer = mangaList.eq(i);
                    const imgEl = divContainer.find('div.c-image-hover > a > img');
                    const coverImage = (_a = imgEl.attr('data-src')) !== null && _a !== void 0 ? _a : '';
                    const anchorEl = divContainer.find('div.post-title > h3 > a');
                    const title = anchorEl.text().trim();
                    const url = (_b = anchorEl.attr('href')) !== null && _b !== void 0 ? _b : '';
                    const authors = divContainer.find('div.mg_author > div.summary-content > a').text().trim().split(' - ');
                    const genres = divContainer
                        .find('div.mg_genres > div.summary-content')
                        .text()
                        .trim()
                        .split(', ');
                    const status = (() => {
                        const mangaBoxStatus = divContainer.find('div.mg_status > div.summary-content').text().trim();
                        switch (mangaBoxStatus) {
                            case 'OnGoing':
                                return 'ongoing';
                            case 'Completed':
                                return 'completed';
                            default:
                                return mangaBoxStatus.toLowerCase();
                        }
                    })();
                    const updatedAt = new Date(divContainer.find('div.meta-item.post-on > span.font-meta').text());
                    mangas.push({ title, url, authors, coverImage, genres, status, updatedAt });
                }
                success_1.default(mangas, callback, res);
            }
            catch (e) {
                failure_1.default(e, callback, rej);
            }
        }));
    }
    getMangaMeta(url, callback = () => void 0) {
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (url == null)
                return failure_1.default('Argument "url" is required', callback, rej);
            try {
                const html = yield automateBrowser_1.default(this.options, (page) => __awaiter(this, void 0, void 0, function* () {
                    yield page.goto(url, { waitUntil: 'domcontentloaded' });
                    yield page.waitForSelector('ul.main');
                    return yield page.evaluate(() => document.body.outerHTML);
                }), {
                    resource: { type: ['document', 'script', 'xhr'], method: 'unblock' },
                    domains: { method: 'block', value: this.BLOCKED_DOMAINS },
                });
                const $ = cheerio_1.default.load(html);
                const title = $('h1').text().trim();
                const ratingStars = $('div.post-rating > div.post-total-rating > span').text();
                const ratingTotalVotes = $('div.post-content_item > div.summary-content.vote-details > span[property="ratingCount"]#countrate').text();
                const rating = {
                    sourceRating: 'mangabox.org',
                    ratingStars: `${ratingStars}/5`,
                    ratingPercentage: `${((Number(ratingStars) / 5) * 100).toFixed(2)}%`,
                    voteCount: ratingTotalVotes,
                };
                const rank = (_b = (_a = $('div.summary-heading:contains("Rank")')
                    .siblings('div.summary-content')
                    .text()
                    .trim()
                    .match(/\d+(st|nd|rd|th|),/g)) === null || _a === void 0 ? void 0 : _a.toString().slice(0, -1)) !== null && _b !== void 0 ? _b : '?';
                const altTitles = $('div.summary-heading:contains("Alternative")')
                    .siblings('div.summary-content')
                    .text()
                    .replace(/\n/g, '')
                    .split('; ')
                    .slice(0, -1);
                const authors = $('div.author-content > a').text().trim().split(' - ');
                const artists = $('div.artist-content > a')
                    .map((_, el) => $(el).text().split(', '))
                    .get();
                const genres = $('div.genres-content > a')
                    .map((_, el) => $(el).text())
                    .get();
                const summary = $('div.summary__content.show-more').children().remove().end().text().trim();
                const status = (() => {
                    const mangaStatus = $('div.post-status > div.post-content_item > div.summary-heading:contains("Status")')
                        .siblings('div.summary-content')
                        .text()
                        .trim();
                    switch (mangaStatus) {
                        case 'OnGoing':
                            return 'ongoing';
                        case 'Completed':
                            return 'completed';
                        default:
                            return mangaStatus.toLowerCase();
                    }
                })();
                const coverImage = (_c = $('div.summary_image > a > img').attr('data-src')) !== null && _c !== void 0 ? _c : '';
                const chapters = [];
                const chapterList = $('ul.main > li');
                const chapterListLength = chapterList.length;
                for (let i = 0; i < chapterListLength; i++) {
                    const chapterContainer = chapterList.eq(i);
                    const anchorEl = chapterContainer.find('a');
                    const chapterName = anchorEl.text().trim();
                    const chapterUrl = (_d = anchorEl.attr('href')) !== null && _d !== void 0 ? _d : '';
                    const date = chapterContainer.find('span.chapter-release-date').text().trim();
                    const chapterDate = date_fns_1.parse(date, 'dd.MM.yyyy', new Date());
                    chapters.push({ name: chapterName, url: chapterUrl, uploadDate: chapterDate });
                }
                success_1.default({
                    title: { main: title, alt: altTitles },
                    authors,
                    artists,
                    genres,
                    coverImage,
                    status,
                    rank,
                    rating,
                    summary,
                    chapters,
                }, callback, res);
            }
            catch (e) {
                failure_1.default(e, callback, rej);
            }
        }));
    }
    getPages(url, callback = () => void 0) {
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            try {
                const $ = yield readHtml_1.default(url, this.options);
                const pages = $('div.reading-content > div.page-break.no-gaps > img')
                    .map((_, el) => { var _a, _b; return (_b = (_a = $(el).attr('data-src')) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : ''; })
                    .get();
                success_1.default(pages, callback, res);
            }
            catch (e) {
                failure_1.default(e, callback, rej);
            }
        }));
    }
}
exports.default = MangaBox;
//# sourceMappingURL=index.js.map