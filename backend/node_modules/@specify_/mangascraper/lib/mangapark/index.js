"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cheerio_1 = __importDefault(require("cheerio"));
const __1 = require("..");
const failure_1 = __importDefault(require("../functions/failure"));
const readHtml_1 = __importDefault(require("../functions/readHtml"));
const success_1 = __importDefault(require("../functions/success"));
const automateBrowser_1 = __importDefault(require("../functions/automateBrowser"));
let memo = [];
class MangaPark {
    constructor(options = {}) {
        this.options = options;
    }
    /**
     * Search up a manga from MangaParkv2
     *
     * @param query - Title of manga. By default, it searches for titles matching this value. If you want to search for author and/or title, pass in an object containing either/both `author` and/or `title`.
     * @param filters - Filters to apply to query
     * @param callback - Callback function
     * @returns Returns an array of mangas from MangaPark (v2)
     * @example
     * ```js
     * const mangapark = new MangaPark();
     * ```
     * ```js
     * mangapark.search('Berserk');
     * ```
     * ```js
     * mangapark.search({ author: 'Gotouge Koyoharu' })
     * ```
     * ```js
     * mangapark.search(null, { type: 'manga', genre: { include: ['Horror'] } })
     * ```
     */
    search(query = '', filters = {}, callback = () => void 0) {
        if (query == null)
            query = '';
        if (filters == null)
            filters = {};
        const { genres, status = 'any', rating = 'any', type = 'any', yearReleased, orderBy = 'most_views', page = 1, } = filters;
        const url = (() => {
            const queryParam = (() => {
                if (query == null || (typeof query === 'string' && query.length === 0))
                    return '';
                if (typeof query === 'string')
                    return `q=${encodeURIComponent(query)}`;
                let author;
                let _query;
                if (query.author == null)
                    author = '';
                else
                    author = `autart=${encodeURIComponent(query.author)}`;
                if (query.title == null)
                    _query = '';
                else
                    _query = `q=${encodeURIComponent(query.title)}`;
                return [_query, author].filter((item) => item.length !== 0).join('');
            })();
            const includeGenres = genres && genres.include && genres.include.length > 0
                ? `genres=${genres.include.map((genre) => __1.MangaParkGenres[genre])}`
                : '';
            const excludeGenres = genres && genres.exclude && genres.exclude.length > 0
                ? `genres-exclude=${genres.exclude.map((genre) => __1.MangaParkGenres[genre])}`
                : '';
            const mangaRating = rating !== 'any' ? `rating=${rating.substring(0, 0)}` : '';
            const mangaStatus = status !== 'any' ? `status=${status}` : '';
            const mangaType = type !== 'any' ? `types=${type}` : '';
            const year = yearReleased ? `years=${yearReleased}` : '';
            const order = `orderby=${__1.MangaParkOrderBy[orderBy]}`;
            const args = [
                queryParam,
                includeGenres,
                excludeGenres,
                mangaRating,
                mangaStatus,
                mangaType,
                year,
                order,
                'st-ss=0',
                `page=${page}`,
            ]
                .filter((i) => i.length !== 0)
                .join('&');
            return `https://v2.mangapark.net/search?${args}`;
        })();
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            if (typeof page !== 'number')
                return failure_1.default('"page" must be a number', callback, rej);
            if (page == null)
                return failure_1.default('Missing argument "page" is required', callback, rej);
            try {
                // Parse HTML document
                const $ = yield readHtml_1.default(url, this.options);
                const titleURLs = $('h2 > a')
                    .map((_, el) => {
                    const anchorEl = $(el);
                    const href = `https://v2.mangapark.net${anchorEl.attr('href')}` || '';
                    const title = anchorEl.attr('title') || '';
                    return {
                        url: href,
                        title,
                    };
                })
                    .get();
                const authors = $('div:contains("Authors/Artists") > b.pd')
                    .prevAll()
                    .map((_, el) => {
                    const text = $(el).text();
                    if (!text.match('Authors/Artists:'))
                        memo = [...memo, text];
                    else {
                        const prevMemo = memo;
                        memo = [];
                        return [prevMemo];
                    }
                })
                    .get();
                const mangaGenres = $('div.field.last > a')
                    .map((_, el) => {
                    const anchorEl = $(el);
                    const text = anchorEl.text();
                    if (anchorEl.next().is('a'))
                        memo = [...memo, text];
                    else {
                        const prevMemo = memo;
                        memo = [];
                        return [prevMemo];
                    }
                })
                    .get();
                const mangaRating = $('div.rate').map((_, el) => {
                    var _a;
                    const divEl = $(el);
                    const ratingText = ((_a = divEl.attr('title')) === null || _a === void 0 ? void 0 : _a.split(' ')) || [];
                    const numerator = Number(ratingText[1]);
                    const denominator = Number(ratingText[3]);
                    const voteCount = Number(ratingText[6]).toLocaleString();
                    return {
                        sourceRating: 'MangaPark.net',
                        voteCount,
                        ratingPercentage: `${((numerator / denominator) * 100).toFixed(2)}%`,
                        ratingStars: `${numerator} / ${denominator}`,
                    };
                });
                const coverImage = $('a.cover > img')
                    .map((_, el) => { var _a; return (_a = $(el).attr('src')) !== null && _a !== void 0 ? _a : ''; })
                    .get();
                const data = titleURLs.map(({ title, url: mangaUrl }, i) => ({
                    title,
                    url: mangaUrl,
                    authors: authors[i],
                    coverImage: coverImage[i],
                    genres: mangaGenres[i],
                    rating: mangaRating[i],
                }));
                success_1.default(data, callback, res);
            }
            catch (e) {
                failure_1.default(e, callback, rej);
            }
        }));
    }
    /**
     * Get the metadata of a manga
     *
     * @param url - URL of manga
     * @param callback - Callback function
     * @returns Returns the metadata of a manga
     * @example
     * ```js
     * const mangapark = new MangaPark();
     * ```
     * ```js
     * await mangapark.getMangaMeta('https://v2.mangapark.net/manga/berserk');
     * ```
     */
    getMangaMeta(url, callback = () => void 0) {
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (url == null)
                return failure_1.default('Missing argument "url" is required', callback, rej);
            try {
                // Parse HTML document
                const html = yield automateBrowser_1.default(this.options, (page) => __awaiter(this, void 0, void 0, function* () {
                    yield page.goto(url, { waitUntil: 'domcontentloaded' });
                    yield page.waitForSelector('h2');
                    return yield page.evaluate(() => document.documentElement.innerHTML);
                }), { resource: { method: 'unblock', type: ['document'] } });
                const $ = cheerio_1.default.load(html);
                const mainTitle = $('h2 > a').text().split(' ').slice(0, -1).join(' ');
                const altTitles = $('th:contains("Alternative")')
                    .siblings('td')
                    .map((_, el) => $(el)
                    .text()
                    .trim()
                    .split(';')
                    .map((text) => text.trim()))
                    .get();
                const rating = (() => {
                    const textArray = $('th:contains("Rating")').siblings('td').text().trim().split(' ');
                    const numerator = Number(textArray[1]);
                    const denominator = Number(textArray[3]);
                    const voteCount = Number(textArray[6]).toLocaleString();
                    return {
                        sourceRating: 'MangaPark.net',
                        voteCount,
                        ratingPercentage: `${((numerator / denominator) * 100).toFixed(2)}%`,
                        ratingStars: `${numerator} / ${denominator}`,
                    };
                })();
                const authors = $('th:contains("Author(s)")')
                    .siblings('td')
                    .children()
                    .map((_, el) => $(el).text().trim())
                    .get();
                const artists = $('th:contains("Artist(s)")')
                    .siblings('td')
                    .children()
                    .map((_, el) => $(el).text().trim())
                    .get();
                const genres = $('th:contains("Genre(s)")')
                    .siblings('td')
                    .children()
                    .map((_, el) => $(el).text().trim())
                    .get();
                const type = (() => {
                    let mangaType = $('th:contains("Type")').siblings().text().trim().split(' ')[1];
                    if (mangaType === 'Webtoon')
                        mangaType = 'manhwa';
                    return mangaType.toLowerCase();
                })();
                const status = $('th:contains("Status")')
                    .siblings()
                    .text()
                    .trim()
                    .toLowerCase();
                const summary = $('div.summary').children().remove().end().text().trim();
                const coverImage = (() => { var _a; return (_a = $('img.w-100').attr('src')) !== null && _a !== void 0 ? _a : ''; })();
                const sourceChapters = [[], [], [], [], [], []];
                $('div.volumes').each((_, div) => {
                    const container = $(div);
                    const version = container
                        .siblings()
                        .find('div > a > span')
                        .text()
                        .slice(8)
                        .toLowerCase();
                    const mangaChapters = container
                        .find('a.visited.ch')
                        .map((__, a) => {
                        var _a;
                        const anchorEl = $(a);
                        const chapterUrl = `https://v2.mangapark.net${(_a = anchorEl.attr('href')) === null || _a === void 0 ? void 0 : _a.slice(0, -1)}` || '';
                        const name = anchorEl.text();
                        return {
                            name,
                            url: chapterUrl,
                        };
                    })
                        .get();
                    const uploadWhen = container
                        .find('span.time')
                        .map((__, span) => $(span).text().trim())
                        .get();
                    const data = mangaChapters.map(({ url: chapterUrl, name }, i) => ({
                        name,
                        url: chapterUrl,
                        uploadWhen: uploadWhen[i],
                    }));
                    switch (version) {
                        case 'duck':
                            sourceChapters[0] = data;
                            break;
                        case 'fox':
                            sourceChapters[1] = data;
                            break;
                        case 'rock':
                            sourceChapters[2] = data;
                            break;
                        case 'panda':
                            sourceChapters[3] = data;
                            break;
                        case 'mini':
                            sourceChapters[4] = data;
                            break;
                        case 'toon':
                            sourceChapters[5] = data;
                        default:
                            break;
                    }
                });
                const recommendedSource = $('div#list > div.stream')
                    .filter((_, el) => !$(el).hasClass('collapsed'))
                    .find('div > div > a > span')
                    .text()
                    .substring(8)
                    .toLowerCase();
                const chapters = {
                    recentlyUpdated: recommendedSource.length === 0 ? undefined : recommendedSource,
                    duck: sourceChapters[0],
                    fox: sourceChapters[1],
                    rock: sourceChapters[2],
                    panda: sourceChapters[3],
                    mini: sourceChapters[4],
                    toon: sourceChapters[5],
                };
                const popularity = (_b = (_a = $('tr > th:contains("Popularity")')
                    .siblings('td')
                    .text()
                    .trim()
                    .match(/\d+\w{2}/)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '?';
                success_1.default({
                    title: {
                        main: mainTitle,
                        alt: altTitles.filter((title) => title.length !== 0),
                    },
                    summary,
                    coverImage,
                    authors,
                    artists: artists.filter((artist) => artist.length !== 0),
                    popularity,
                    genres,
                    rating,
                    type,
                    status,
                    chapters,
                }, callback, res);
            }
            catch (e) {
                failure_1.default(e, callback, rej);
            }
        }));
    }
    /**
     * Get a list of mangas from MangaPark's latest manga releases
     *
     * @param options - Options to provide when getting latest updates
     * @param callback - Callback function
     * @returns Returns an array of mangas from MangaPark's latest manga releases page
     */
    getLatestUpdates(options = { page: 1 }, callback = () => void 0) {
        const { page } = options;
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (page < 1)
                return failure_1.default('Argument "page" must be greater than or equal to 1', callback, rej);
            try {
                const $ = yield readHtml_1.default(`https://v2.mangapark.net/latest/${page}`, this.options, { resource: { type: ['document', 'image'], method: 'unblock' } }, 'domcontentloaded');
                const itemsOnPage = $('div.d-flex.flex-row.item');
                const lengthOfItems = itemsOnPage.length;
                const mangas = [];
                for (let i = 0; i < lengthOfItems; i++) {
                    const divContainer = itemsOnPage.eq(i);
                    const anchorEl = divContainer.children('a');
                    const title = (_a = $(anchorEl).attr('title')) !== null && _a !== void 0 ? _a : '';
                    const href = (_b = $(anchorEl).attr('href')) !== null && _b !== void 0 ? _b : '';
                    const imgEl = $(anchorEl).children('img');
                    const src = (_c = $(imgEl).attr('src')) !== null && _c !== void 0 ? _c : '';
                    const genres = divContainer
                        .find('div.mb-2.gens')
                        .map((_, el) => $(el).text().trim().split(', '))
                        .get();
                    const uploadWhen = divContainer.children('ul').children('li').eq(0).find('span.time').text();
                    mangas.push({
                        title,
                        url: `https://v2.mangapark.net${href}`,
                        coverImage: src,
                        genres,
                        updatedWhen: uploadWhen,
                    });
                }
                success_1.default(mangas, callback, res);
            }
            catch (e) {
                failure_1.default(e, callback, rej);
            }
        }));
    }
    /**
     * Get raw image URLs from a chapter URL. Since MangaPark uses Cloudflare, make sure to add `referer: https://v2.mangapark.net/` to every GET request when fetching the image or else the image will not load.
     *
     * @param url - URL of chapter
     * @param callback - Callback function
     * @returns Returns an array of strings that contain the img URLs of the pages from the chapter URL
     * @example
     * ```js
     * const mangapark = new MangaPark();
     * ```
     * ```js
     * await mangapark.getPages('https://xcdn-222.mangapark.net/10102/69/9b/5c791a3ae9c047226f2bb996/02_75696_711_1114.webp');
     * ```
     */
    getPages(url, callback = () => void 0) {
        const BLOCKED_REQUESTS = [
            'https://v2.mangapark.net/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/jqueryui/',
            'https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/',
            'https://cdnjs.cloudflare.com/ajax/libs/axios/',
            'https://static.mangapark.net/v2/js/global.js',
            'https://static.mangapark.net/v2/js/manga-global.js',
            'https://v2.mangapark.net/book-list/',
            'https://mangapark.net/misc/',
            'https://mangaparkcom.disqus.com/',
            'https://www.googletagmanager.com/',
            'https://hm.baidu.com/',
            'https://s7.addthis.com/',
            'https://tags.crwdcntrl.net/',
            'https://cdn.run-syndicate.com/',
            'https://go.bebi.com/',
            'https://st.bebi.com/',
            'https://run-syndicate.com/',
            'https://platform.bidgear.com/',
        ];
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            if (url == null)
                return failure_1.default('Missing argument "url" is required', callback, rej);
            try {
                const data = yield automateBrowser_1.default(this.options, (page) => __awaiter(this, void 0, void 0, function* () {
                    yield page.goto(url, { waitUntil: 'domcontentloaded' });
                    yield page.addScriptTag({ path: require.resolve('jquery') });
                    yield page.waitForSelector('a.img-link');
                    return yield page.evaluate(() => {
                        const { $ } = window;
                        return $('a.img-link > img')
                            .map((_, el) => $(el).attr('src') || '')
                            .get();
                    });
                }), {
                    domains: { method: 'block', value: BLOCKED_REQUESTS },
                    resource: { method: 'unblock', type: ['document', 'script'] },
                });
                success_1.default(data, callback, res);
            }
            catch (e) {
                failure_1.default(e, callback, rej);
            }
        }));
    }
}
exports.default = MangaPark;
//# sourceMappingURL=index.js.map