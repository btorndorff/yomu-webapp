"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const failure_1 = __importDefault(require("../functions/failure"));
const readHtml_1 = __importDefault(require("../functions/readHtml"));
const success_1 = __importDefault(require("../functions/success"));
class MangaParkv2 {
    getMangas(search = '', options = {}, callback = () => { }) {
        const { genres, searchFor = 'title', status = 'all', rating, type, page = 1, yearReleased, showSummary = false, sortBy = 'Rating', } = options;
        function generateURL() {
            var _a;
            const q = searchFor === 'title'
                ? search.length !== 0
                    ? `q=${encodeURIComponent(search)}`
                    : ''
                : `autart=${encodeURIComponent(search)}`; // Short for query
            const orderBy = `orderby=${__1.MangaParkv2SortByEnum[sortBy]}`;
            const include_genres = (genres === null || genres === void 0 ? void 0 : genres.include)
                ? `genres=${genres === null || genres === void 0 ? void 0 : genres.include.map((genre) => __1.MangaParkv2Genres[genre]).join(',')}`
                : '';
            const exclude_genres = (genres === null || genres === void 0 ? void 0 : genres.exclude)
                ? `genres-exclude=${(_a = genres === null || genres === void 0 ? void 0 : genres.exclude) === null || _a === void 0 ? void 0 : _a.map((genre) => __1.MangaParkv2Genres[genre]).join(',')}`
                : '';
            const mangaStatus = status === 'all' ? `status=${status}` : ``;
            const mangaRating = rating ? `rating=${__1.MangaParkv2RatingEnum[rating]}` : '';
            const mangaType = type ? `types=${type}` : '';
            const stss = `st-ss=${showSummary ? '1' : '0'}`; // Short for show summary
            const years = typeof yearReleased !== 'undefined' ? `years=${yearReleased}` : '';
            const url_page = `page=${page}`;
            let url_args = [
                q,
                orderBy,
                include_genres,
                exclude_genres,
                mangaStatus,
                mangaRating,
                mangaType,
                years,
                stss,
                url_page,
            ]
                .filter((el) => el.length > 0)
                .join('&');
            const base_url = `https://v2.mangapark.net/search?${url_args}`;
            console.log(base_url);
            return base_url;
        }
        return new Promise((res) => __awaiter(this, void 0, void 0, function* () {
            if (page <= 0)
                return failure_1.default(new Error('"page" must be greater than 0'), callback);
            try {
                const $ = yield readHtml_1.default(generateURL());
                const mainTitles = [];
                const altTitles = [];
                const urls = [];
                const authors = [];
                const genres = [];
                const summaries = [];
                const coverImages = [];
                const ratings = [];
                $(`div.manga-list > div.item > table > tbody > tr > td > h2 > a`).each((_, el) => {
                    const title = $(el).text();
                    const url = $(el).attr('href');
                    if (typeof title !== 'undefined')
                        mainTitles.push(title);
                    if (typeof url !== 'undefined')
                        urls.push(url);
                });
                const mangaList = new Array(mainTitles.length).fill('').map((_, i) => ({
                    title: mainTitles[i],
                    url: urls[i],
                }));
                console.log(mainTitles);
                success_1.default(mangaList, callback, res);
            }
            catch (e) {
                return failure_1.default(new Error(e), callback);
            }
        }));
    }
}
exports.default = MangaParkv2;
//# sourceMappingURL=v2.js.map