"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const date_fns_1 = require("date-fns");
const __1 = require("..");
const failure_1 = __importDefault(require("../functions/failure"));
const readHtml_1 = __importDefault(require("../functions/readHtml"));
const splitAltTitles_1 = __importDefault(require("../functions/splitAltTitles"));
const success_1 = __importDefault(require("../functions/success"));
class Mangahasu {
    constructor(options = {}) {
        this.options = options;
    }
    /**
     *
     * @param query - Search manga, name of author and artist. If you only want to search for a specific characteristic of a manga (such as searching for author name only), use an object which has the fields `author`, `artist`, and `title`
     * @param filters - Filters to apply when searching up the manga such as including/excluding genres or newest releases.
     * @param callback - Callback function
     * @returns Returns an array of manga from mangahasu
     * @example
     * ```js
     * import { Mangahasu } from "@specify_/mangascraper";
     * const mangahasu = new Mangahasu();
     *
     * (await () => {
     *  const mangas = await mangahasu.search({ title: "One Piece", author: "Oda" }, { genres: { include: ["Action", "Adventure"], exclude: ["Mystery"]}, status: "ongoing" })
     * console.log(mangas); // Output: [ { title: 'One Piece - Digital Colored Comics' ... }]
     * })();
     * ```
     */
    search(query = '', filters = {}, callback = () => void 0) {
        if (query == null)
            query = '';
        if (filters == null)
            filters = {};
        const { genres = {}, status = 'any', type = 'any', page = 1 } = filters;
        function generateURL() {
            const keyword = (() => {
                if (typeof query === 'string')
                    return `keyword=${encodeURIComponent(query)}`;
                return query.title != null ? `keyword=${encodeURIComponent(query.title)}` : '';
            })();
            const author = typeof query !== 'string' && query.author != null ? `author=${encodeURIComponent(query.author)}` : '';
            const artist = typeof query !== 'string' && query.artist != null ? `artist=${encodeURIComponent(query.artist)}` : '';
            const typeid = type !== 'any' ? `typeid=${__1.MangahasuTypes[type]}` : '';
            const includeGenres = genres.include
                ? `g_i[]=${genres.include.map((genre) => __1.MangahasuGenres[genre])}`
                : '';
            const excludeGenres = genres.exclude
                ? `g_e[]=${genres.exclude.map((genre) => __1.MangahasuGenres[genre])}`
                : '';
            const mangaStatus = status !== 'any' ? `status=${status === 'completed' ? '1' : '2'}` : '';
            const urlArgs = [keyword, author, artist, typeid, includeGenres, excludeGenres, mangaStatus]
                .filter((arg) => arg.length > 0)
                .join('&');
            const baseUrl = `https://mangahasu.se/advanced-search.html?${urlArgs}&page=${page}`;
            return baseUrl;
        }
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            if (page == null)
                return failure_1.default('Missing argument "page" is required', callback, rej);
            if (page <= 0)
                return failure_1.default('"page" must be greater than 0', callback, rej);
            if (typeof query !== 'string' && query.artist == null && query.title == null && query.author == null)
                query = '';
            try {
                /** Parse HTML Document */
                const $ = yield readHtml_1.default(generateURL(), this.options);
                /** Get manga titles and URLs */
                const titlesURL = $(`ul.list_manga > li > div.div_item > div.info-manga > a.name-manga`)
                    .map((_, el) => {
                    const title = $(el).text();
                    const url = $(el).attr('href');
                    if (typeof url !== 'undefined' && typeof title !== 'undefined') {
                        return {
                            title: title.trim(),
                            url,
                        };
                    }
                })
                    .get();
                /** Get manga covers */
                const coverImages = $(`ul.list_manga > li > div.div_item > div.wrapper_imgage > a > img`)
                    .map((_, el) => { var _a; return (_a = $(el).attr('src')) !== null && _a !== void 0 ? _a : ''; })
                    .get();
                // const mangaList: Manga<Mangahasu>[] = [];
                // for (let i = 0; i < titlesURL.length; i++) {
                //   mangaList.push({ title: titlesURL[i].title, url: titlesURL[i].url, coverImage: coverImages[i] });
                // }
                const mangaList = titlesURL.map(({ title, url }, i) => ({
                    title,
                    url,
                    coverImage: coverImages[i],
                }));
                success_1.default(mangaList, callback, res);
            }
            catch (e) {
                return failure_1.default(e, callback, rej);
            }
        }));
    }
    /**
     * Get metadata of a manga from its url
     *
     * @param url - URL of manga
     * @param callback - Callback function
     * @returns Returns the metadata of a manga from the given url
     * @example
     * ```js
     * import { Mangahasu } from "@specify_/mangascraper";
     * const mangahasu = new Mangahasu();
     *
     * (async () => {
     *  const one_piece = await mangahasu.getMangaMeta('https://mangahasu.se/one-piece-p10328.html');
     *  console.log(one_piece); // Output: { title: { main: "One Piece", alt: ["ワンピース", ... ] }, ... }
     * })();
     * ```
     */
    getMangaMeta(url, callback = () => void 0) {
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (url == null)
                return failure_1.default('Missing argument "url" is required', callback, rej);
            try {
                /** Parse HTML document */
                const $ = yield readHtml_1.default(url, this.options);
                let title = '';
                let altTitles = [];
                let summary = '';
                let authors = [];
                let artists = [];
                let genres = [];
                let type = '';
                let status = '';
                let views = '';
                let rating = {};
                /** Get manga title */
                title = $(`div.info-title > h1`).text();
                /** Get manga alternate titles */
                altTitles = splitAltTitles_1.default($(`div.info-title > h3`).text());
                /** Get manga summary */
                summary = $(`div.content-info > h3:contains("Summary")`).siblings('div').text().trim();
                /** Get manga authors */
                authors = $(`div.row > b:contains("Author(s)")`).siblings('span.info').text().trim().split('; ');
                /** Get manga artists */
                artists = $(`div.box-des > div.detail_item > b:contains("Artist(s)")`)
                    .siblings('span.info')
                    .text()
                    .trim()
                    .split('; ');
                /** Get manga type */
                type = $(`div.detail_item > b:contains("Type")`).siblings('span.info').text().trim();
                /** Get manga genres */
                genres = $(`div.detail_item > b:contains("Genre(s)")`)
                    .siblings('span.info')
                    .text()
                    .trim()
                    .split(', ');
                /** Get status of the manga */
                status = $(`div.detail_item > b:contains("Status")`).siblings('span.info').text().trim();
                /** Get manga views */
                views = Number($(`div.detail_item > div.row > b:contains("Views")`).siblings('span.info').text().trim()).toLocaleString();
                /** Get manga rating */
                const spanRatings = $(`div[class="div-evaluate detail_item"] > span.info > span.ratings`).text().trim();
                let ratingStars;
                let ratingPercentage;
                if (spanRatings.length !== 0) {
                    ratingStars = `${spanRatings}/5`;
                    ratingPercentage = `${((Number(spanRatings) / 5) * 100).toFixed(2)}%`;
                }
                const voteCount = Number($(`div[class="div-evaluate detail_item"] > span.info > span.div_evaluate`).text().trim()).toLocaleString();
                rating = {
                    sourceRating: 'Mangahasu.se',
                    ratingPercentage,
                    ratingStars,
                    voteCount,
                };
                /** Get manga cover image */
                const coverImage = (_a = $(`div.container > div.wrapper_content > div.info-img > img`).attr('src')) !== null && _a !== void 0 ? _a : '';
                /** Get manga chapters */
                const chapters = $(`div.content-info > div.list-chapter > table.table > tbody > tr`)
                    .map((_, el) => {
                    const anchorEl = $(el).children('td.name').children('a');
                    const chapterName = anchorEl.text().replace(title, '').trim();
                    const chapterUrl = anchorEl.attr('href');
                    const chapterDate = date_fns_1.parse($(el).children('td.date-updated').text().trim(), 'MMM dd, yyyy', new Date());
                    if (typeof chapterUrl !== 'undefined')
                        return { name: chapterName, url: chapterUrl, uploadDate: chapterDate };
                })
                    .get();
                success_1.default({
                    title: { main: title, alt: altTitles },
                    summary,
                    authors,
                    artists,
                    type,
                    status,
                    genres,
                    views,
                    rating,
                    coverImage,
                    chapters,
                }, callback, res);
            }
            catch (e) {
                return failure_1.default(e, callback, rej);
            }
        }));
    }
    /**
     * Get a list of mangas from Mangahasu's latest releases
     *
     * @param options - Options to provide when getting latest updates
     * @param callback - Callback function
     * @returns Returns an array of mangas from Mangahasu's latest releases page.
     */
    getLatestUpdates(options = { page: 1 }, callback = () => void 0) {
        const { page } = options;
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (page < 1)
                return failure_1.default('Argument "page" must be greater than or equal to 1', callback, rej);
            try {
                const $ = yield readHtml_1.default(`https://mangahasu.se/latest-releases.html?page=${page}`, this.options);
                const mangaList = $('ul.list_manga > li');
                const mangaListLength = mangaList.length;
                const mangas = [];
                for (let i = 0; i < mangaListLength; i++) {
                    const divContainer = mangaList.eq(i);
                    const imgEl = divContainer.find('img');
                    const src = (_a = imgEl.attr('src')) !== null && _a !== void 0 ? _a : '';
                    const alt = (_b = imgEl.attr('alt')) !== null && _b !== void 0 ? _b : '';
                    const href = (_c = divContainer.find('a.name-manga').attr('href')) !== null && _c !== void 0 ? _c : '';
                    mangas.push({ title: alt, coverImage: src, url: href });
                }
                success_1.default(mangas, callback, res);
            }
            catch (e) {
                return failure_1.default(e, callback, rej);
            }
        }));
    }
    /**
     * Get raw image URLs from chapter URL.
     * Note: Each image URL does not require any `headers` when making requests
     *
     * @param url - URL of chapter
     * @param callback - Callback function
     * @returns Returns an array of URLs of each page in the chapter
     * @example
     * ```js
     * import { Mangahasu } from "@specify_/mangascraper";
     * const mangahasu = new Mangahasu();
     *
     * (async () => {
     *  const pages = mangahasu.getPages("https://mangahasu.se/solo-leveling/chapter-0-prologue-v1-c628457.html");
     *  console.log(pages); // Output: [ 'https://.../0000-001.png', 'https://.../0000-002.png', 'https://.../0000-003.png', ... ]
     * })();
     * ```
     */
    getPages(url, callback = () => void 0) {
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            if (url == null)
                return failure_1.default('Missing argument "url" is required', callback, rej);
            try {
                /** parse HTML document */
                const $ = yield readHtml_1.default(url, this.options);
                /** Get URLs of each img element */
                const pages = $(`div.img-chapter > div.img > img`)
                    .map((_, el) => {
                    const img = $(el).attr('src');
                    if (typeof img !== 'undefined')
                        return img;
                })
                    .get();
                success_1.default(pages, callback, res);
            }
            catch (e) {
                return failure_1.default(e, callback, rej);
            }
        }));
    }
}
exports.default = Mangahasu;
//# sourceMappingURL=index.js.map